// Polymarket Copy-Trader Database Schema
// This is the source of truth for all tables

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// Settings - Global guardrails controlled via dashboard
// ============================================================================
model Settings {
  id                      Int      @id @default(1)
  
  // Base guardrails
  ratioDefault            Float    @default(0.01)
  maxUsdcPerTrade         Float    @default(2)
  maxUsdcPerDay           Float    @default(10)
  maxPriceMovePct         Float    @default(0.01)
  maxSpread               Float    @default(0.02)
  
  // Operation-specific modifiers
  sellMaxPriceMovePct     Float    @default(0.05)  // 5x more lenient for SELL
  sellMaxSpread           Float    @default(0.10)  // 5x more lenient for SELL
  sellAlwaysAttempt       Boolean  @default(true)  // Never skip SELL for price/spread
  splitMergeAlwaysFollow  Boolean  @default(true)  // Always follow SPLIT/MERGE
  
  // Phase 6: Risk Controls
  skipMakerTrades         Boolean  @default(true)  // Skip if leader was maker (passive)
  maxUsdcPerEvent         Float    @default(50)    // Max exposure per market event
  maxOpenPositions        Int      @default(10)    // Max concurrent open positions
  
  updatedAt               DateTime @updatedAt

  @@map("settings")
}

// ============================================================================
// Leaders - Wallets being tracked for copy-trading
// ============================================================================
model Leader {
  id        String   @id @default(uuid())
  label     String
  wallet    String   @unique // lowercase 0x...
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())

  // Per-leader overrides (null = use global settings)
  ratio           Float?
  maxUsdcPerTrade Float?
  maxUsdcPerDay   Float?
  maxUsdcPerEvent Float?
  skipMakerTrades Boolean?

  tradeRaws   TradeRaw[]
  trades      Trade[]
  leaderFills LeaderFill[]

  @@map("leaders")
}

// ============================================================================
// Raw Events - Store full API payloads for audit and reprocessing
// ============================================================================
model TradeRaw {
  id         String   @id @default(uuid())
  leaderId   String
  leader     Leader   @relation(fields: [leaderId], references: [id])
  source     String   // e.g., "data-api/activity"
  payload    Json     // entire trade JSON from API
  ingestedAt DateTime @default(now())

  trade Trade?

  @@map("trade_raw")
}

model QuoteRaw {
  id         String   @id @default(uuid())
  marketKey  String
  payload    Json     // entire quote JSON from API
  capturedAt DateTime @default(now())

  quote Quote?

  @@map("quote_raw")
}

// ============================================================================
// Normalized Trades - Parsed and deduplicated trade records
// ============================================================================
model Trade {
  id          String   @id @default(uuid())
  leaderId    String
  leader      Leader   @relation(fields: [leaderId], references: [id])
  dedupeKey   String   @unique // leaderWallet|txHash|side|conditionId|outcome|size|price
  txHash      String
  tradeTs     DateTime // leader trade timestamp
  detectedAt  DateTime @default(now()) // when our watcher saw it
  side        TradeSide
  conditionId String
  outcome     String   // YES/NO or outcomeIndex
  leaderPrice Decimal  @db.Decimal(20, 10)
  leaderSize  Decimal  @db.Decimal(20, 10) // shares
  leaderUsdc  Decimal  @db.Decimal(20, 10) // notional
  title       String?  // market title, nullable
  isBackfill  Boolean  @default(false) // true if from initial leader backfill (historical)
  rawId       String   @unique
  raw         TradeRaw @relation(fields: [rawId], references: [id])

  paperIntents PaperIntent[]
  executionAttempts ExecutionAttempt[]

  @@index([leaderId])
  @@index([conditionId])
  @@index([tradeTs])
  @@index([isBackfill])
  @@map("trades")
}

enum TradeSide {
  BUY
  SELL
  SPLIT
  MERGE
}

// ============================================================================
// Market Mapping - Maps (conditionId, outcome) to tradable instrument
// ============================================================================
model MarketMapping {
  id          String   @id @default(uuid())
  conditionId String
  outcome     String
  marketKey   String   // internal canonical key
  clobTokenId String?  // token ID for CLOB API
  assetId     String?  // alternative asset ID
  updatedAt   DateTime @updatedAt

  @@unique([conditionId, outcome])
  @@map("market_mapping")
}

// ============================================================================
// PHASE 2: Market Registry - Pre-loaded market metadata from Gamma API
// ============================================================================

// MarketRegistry - Cached market metadata from Gamma API
model MarketRegistry {
  id               String   @id @default(uuid())
  conditionId      String   @unique  // primary lookup key
  
  // Market metadata
  title            String
  slug             String?
  category         String?
  endDate          DateTime?
  
  // Trading status
  enableOrderBook  Boolean  @default(true)
  active           Boolean  @default(true)
  closed           Boolean  @default(false)
  
  // Token data (JSON array of {tokenId, outcome})
  tokens           Json     // Array<{tokenId: string, outcome: string, winner?: boolean}>
  
  // Additional metadata
  description      String?
  
  // Sync tracking
  gammaMarketId    String?  // Gamma API market ID
  lastSyncedAt     DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  tokenIndexes     TokenIndex[]

  @@index([enableOrderBook])
  @@index([active])
  @@index([lastSyncedAt])
  @@map("market_registry")
}

// TokenIndex - Fast lookup from tokenId to market/outcome
model TokenIndex {
  id            String          @id @default(uuid())
  tokenId       String          @unique  // CLOB token ID - primary lookup key
  
  // References
  registryId    String
  registry      MarketRegistry  @relation(fields: [registryId], references: [id], onDelete: Cascade)
  
  // Denormalized for fast lookups (avoid joins)
  conditionId   String
  outcome       String
  title         String?
  
  createdAt     DateTime        @default(now())

  @@index([conditionId])
  @@map("token_index")
}


// ============================================================================
// Quotes - Top-of-book snapshots (best bid/ask)
// ============================================================================
model Quote {
  id         String   @id @default(uuid())
  marketKey  String
  capturedAt DateTime @default(now())
  bestBid    Decimal  @db.Decimal(20, 10)
  bestAsk    Decimal  @db.Decimal(20, 10)
  bidSize    Decimal? @db.Decimal(20, 10)
  askSize    Decimal? @db.Decimal(20, 10)
  rawId      String   @unique
  raw        QuoteRaw @relation(fields: [rawId], references: [id])

  paperFills PaperFill[]

  @@index([marketKey])
  @@index([capturedAt])
  @@map("quotes")
}

// ============================================================================
// Paper Trading - Intents and simulated fills
// ============================================================================
model PaperIntent {
  id              String          @id @default(uuid())
  tradeId         String
  trade           Trade           @relation(fields: [tradeId], references: [id])
  ratio           Decimal         @db.Decimal(10, 6) // e.g., 0.01
  yourUsdcTarget  Decimal         @db.Decimal(20, 10)
  yourSide        TradeSide
  limitPrice      Decimal         @db.Decimal(20, 10) // the price you would try
  decision        IntentDecision
  decisionReason  String          // e.g., SKIP_PRICE_MOVED, SKIP_SPREAD_TOO_WIDE
  createdAt       DateTime        @default(now())

  paperFill PaperFill?

  @@index([tradeId])
  @@index([decision])
  @@map("paper_intents")
}

enum IntentDecision {
  TRADE
  SKIP
}

model PaperFill {
  id             String    @id @default(uuid())
  intentId       String    @unique
  intent         PaperIntent @relation(fields: [intentId], references: [id])
  filled         Boolean
  fillPrice      Decimal?  @db.Decimal(20, 10)
  fillAt         DateTime?
  slippageAbs    Decimal?  @db.Decimal(20, 10)
  slippagePct    Decimal?  @db.Decimal(10, 6)
  matchSamePrice Boolean
  quoteId        String?
  quote          Quote?    @relation(fields: [quoteId], references: [id])

  @@map("paper_fills")
}

// ============================================================================
// Positions - Track accumulated shares per market for P&L
// ============================================================================
model Position {
  id             String   @id @default(uuid())
  marketKey      String
  conditionId    String
  outcome        String
  title          String?
  shares         Float    @default(0)
  avgEntryPrice  Float    @default(0)
  totalCostBasis Float    @default(0)
  isClosed       Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  resolutions    Resolution[]

  @@unique([marketKey, outcome])
  @@index([isClosed])
  @@map("positions")
}

// ============================================================================
// Resolutions - Record when positions are closed (market resolved or sold)
// ============================================================================
model Resolution {
  id              String   @id @default(uuid())
  positionId      String
  position        Position @relation(fields: [positionId], references: [id])
  resolvedOutcome String   // e.g., YES, NO, MANUAL_CLOSE
  resolutionPrice Float
  realizedPnl     Float
  resolvedAt      DateTime @default(now())

  @@index([positionId])
  @@map("resolutions")
}

// ============================================================================
// P&L Snapshots - Historical P&L data for graphing
// ============================================================================
model PnlSnapshot {
  id              String   @id @default(uuid())
  timestamp       DateTime @default(now())
  totalCostBasis  Float
  unrealizedPnl   Float
  realizedPnl     Float
  totalPnl        Float
  positionCount   Int

  @@index([timestamp])
  @@map("pnl_snapshots")
}

// ============================================================================
// PHASE 1: Polygon Logs + Execution Tracking
// ============================================================================

// Leader Fill Raw - Raw payloads from any source (data_api or polygon)
model LeaderFillRaw {
  id         String         @id @default(uuid())
  source     FillSource     // data_api or polygon
  payload    Json           // entire payload for audit/reprocessing
  createdAt  DateTime       @default(now())

  leaderFill LeaderFill?

  @@map("leader_fill_raw")
}

enum FillSource {
  data_api
  polygon
}

// Leader Fill - Canonical normalized leader fill from any source
model LeaderFill {
  id               String         @id @default(uuid())
  leaderId         String
  leader           Leader         @relation(fields: [leaderId], references: [id])
  source           FillSource

  // Chain identity (nullable for data_api source)
  exchangeAddress  String?        // contract address
  blockNumber      Int?
  txHash           String?
  logIndex         Int?
  orderHash        String?

  // Participants (nullable for data_api source)
  maker            String?
  taker            String?
  leaderRole       LeaderRole     @default(unknown)

  // Trade details
  tokenId          String         // CLOB token ID
  conditionId      String
  outcome          String
  side             TradeSide
  leaderPrice      Decimal        @db.Decimal(20, 10)
  leaderSize       Decimal        @db.Decimal(20, 10)  // shares
  leaderUsdc       Decimal        @db.Decimal(20, 10)  // notional

  // Timestamps
  fillTs           DateTime       // when the fill happened (block time or API timestamp)
  detectedAt       DateTime       @default(now())  // when we detected it

  // Metadata
  title            String?
  isBackfill       Boolean        @default(false)

  // Dedupe and raw reference
  dedupeKey        String         @unique  // exchange|block|tx|logIndex for polygon, or existing key for data_api
  rawId            String         @unique
  raw              LeaderFillRaw  @relation(fields: [rawId], references: [id])

  // Relations
  executionAttempts ExecutionAttempt[]

  @@index([leaderId])
  @@index([conditionId])
  @@index([fillTs])
  @@index([blockNumber])
  @@index([txHash])
  @@map("leader_fills")
}

enum LeaderRole {
  maker
  taker
  unknown
}

// Execution Attempt - One per leader fill we decide to copy (or skip)
model ExecutionAttempt {
  id               String              @id @default(uuid())
  
  // Source identity - at least one should be set
  leaderFillId     String?             // FK to LeaderFill (new flow)
  leaderFill       LeaderFill?         @relation(fields: [leaderFillId], references: [id])
  tradeId          String?             // FK to Trade (legacy flow)
  trade            Trade?              @relation(fields: [tradeId], references: [id])

  // Execution mode
  mode             ExecutionMode

  // Decision
  decision         IntentDecision      // TRADE or SKIP
  decisionReason   String?             // structured reason

  // Order details
  ratio            Decimal             @db.Decimal(10, 6)
  tokenId          String
  conditionId      String
  outcome          String
  side             TradeSide
  sizeSharesTarget Decimal             @db.Decimal(20, 10)
  limitPrice       Decimal             @db.Decimal(20, 10)
  ttlMs            Int                 @default(30000)  // 30 second default TTL

  // Status tracking
  status           ExecutionStatus     @default(SUBMITTED)
  placedAt         DateTime?
  doneAt           DateTime?

  createdAt        DateTime            @default(now())

  // Relations
  executionFills   ExecutionFill[]

  @@index([leaderFillId])
  @@index([status])
  @@index([createdAt])
  @@map("execution_attempts")
}

enum ExecutionMode {
  paper
  live
}

enum ExecutionStatus {
  SKIPPED     // decision was SKIP
  SUBMITTED   // order placed, waiting for fills
  PARTIAL     // partially filled
  FILLED      // fully filled
  CANCELED    // canceled (TTL expired or manual)
  FAILED      // failed to execute
}

// Execution Fill - Zero+ rows per attempt (supports partial fills)
model ExecutionFill {
  id            String           @id @default(uuid())
  attemptId     String
  attempt       ExecutionAttempt @relation(fields: [attemptId], references: [id])

  filledShares  Decimal          @db.Decimal(20, 10)
  fillPrice     Decimal          @db.Decimal(20, 10)
  feeUsdc       Decimal?         @db.Decimal(20, 10)
  fillAt        DateTime         @default(now())

  @@index([attemptId])
  @@map("execution_fills")
}

// Polygon Cursor - Track last processed block for gap-fill on restart
model PolygonCursor {
  id                   String   @id @default(uuid())
  exchangeAddress      String   // CTF or NegRisk contract
  leaderAddress        String   // leader wallet being tracked
  role                 LeaderRole  // maker or taker
  lastProcessedBlock   Int
  updatedAt            DateTime @updatedAt

  @@unique([exchangeAddress, leaderAddress, role])
  @@map("polygon_cursors")
}

// ============================================================================
// Phase 3.5: Latency Tracking + Dashboard Controls
// ============================================================================

// Latency Event - Track each detection event for latency comparison
model LatencyEvent {
  id            String   @id @default(uuid())
  dedupeKey     String   // txHash|logIndex - links both sources
  source        String   // 'data_api' | 'polygon'
  detectedAt    DateTime // When this source detected the trade
  tokenId       String
  conditionId   String
  leaderWallet  String
  side          String   // BUY | SELL
  usdcAmount    Float
  createdAt     DateTime @default(now())

  @@index([dedupeKey])
  @@index([createdAt])
  @@map("latency_events")
}

// Latency Stats - Aggregated statistics for dashboard display
model LatencyStats {
  id              String   @id @default(uuid())
  period          String   // 'hour' | 'day' | 'week'
  periodStart     DateTime
  polygonWins     Int      @default(0)
  dataApiWins     Int      @default(0)
  ties            Int      @default(0)
  avgPolygonMs    Float?   // Average detection time for Polygon
  avgDataApiMs    Float?   // Average detection time for Data API
  avgDeltaMs      Float?   // Average difference (positive = Polygon faster)
  totalEvents     Int      @default(0)
  createdAt       DateTime @default(now())

  @@unique([period, periodStart])
  @@map("latency_stats")
}

// Worker Config - Store runtime configuration changeable from dashboard
model WorkerConfig {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt

  @@map("worker_config")
}
